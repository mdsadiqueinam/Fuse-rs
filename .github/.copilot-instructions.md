# GitHub Copilot Instructions for Fuse-rs

## Project Overview

Fuse-rs is a lightweight fuzzy-search library for Rust, providing a Rust port of the popular Fuse.js JavaScript library. The project supports multiple targets including native Rust, WebAssembly (for browsers), and Node.js bindings.

## Project Structure

This is a Rust workspace with three main crates:
- `fuse-rs`: Core library implemented in Rust
- `fuse-wasm`: WebAssembly bindings using wasm-bindgen
- `fuse-node`: Node.js bindings using Neon

## Core Architecture

### Module Organization

The core `fuse-rs` library follows a modular architecture:

- **core/**: Main functionality
  - `fuse.rs`: Primary search implementation
  - `options/`: Configuration for search behavior
  - `results/`: Types for representing search results
  - `compute_score.rs`: Scoring algorithms
  - `query_parser.rs`: Logical query parsing with AND/OR operations
  
- **search/**: Search algorithms
  - `bitmap/`: Bitap algorithm implementation for fuzzy matching
  - `extended/`: Extended search with command-like syntax support
  
- **helpers/**: Utility functions
  - `get.rs`: Path-based property access
  - `diacritics.rs`: Accent/diacritic mark handling
  
- **tools/**: Supporting infrastructure
  - `key_store.rs`: Management of searchable fields
  - `norm.rs`: Field length normalization
  - `fuse_index.rs`: Search indexing

### Search Algorithms

1. **Bitmap Search**: Uses the Bitap algorithm for efficient fuzzy string matching
2. **Extended Search**: Supports advanced query syntax with operators like:
   - `=exact`: Exact match
   - `^prefix`: Prefix exact match
   - `suffix$`: Suffix exact match
   - `!inverse`: Inverse exact match
   - `"fuzzy"`: Fuzzy match (quoted)

### Key Design Patterns

1. **Builder Pattern**: Used for configuration options
2. **Strategy Pattern**: Different search algorithms implement `Searcher` trait
3. **Single Responsibility**: Each module has a focused responsibility
4. **Error Handling**: Uses `Result<T, FuseError>` for error propagation

## Coding Conventions

### File Structure
Each file follows this structure:
1. Module documentation (`//!`) at the top
2. Imports grouped by source (std, external, internal)
3. Types & Constants
4. Public API
5. Implementation Details
6. Tests

### Code Sections
Use this divider to separate logical sections:
```rust
//----------------------------------------------------------------------
// Section Name
//----------------------------------------------------------------------
```

### Naming Conventions
- Types: PascalCase (`FuseOptions`, `SearchResult`)
- Functions/variables: snake_case (`search_in`, `pattern_length`)
- Constants: SCREAMING_SNAKE_CASE (`MAX_BITS`, `OR_TOKEN`)
- Modules: snake_case (`query_parser`, `bitmap_search`)

### Error Handling
- Use `Result<T, FuseError>` for fallible operations
- Prefer early returns with `?` operator
- Provide descriptive error messages

### Performance Considerations
- Use `Cow<str>` for string parameters that might be borrowed or owned
- Implement `Clone` only when necessary
- Use `&str` over `String` in function parameters when possible
- Consider memory allocation patterns in hot paths

## API Design Principles

### Core Library Usage Pattern
```rust
use fuse_rs::{Fuse, FuseOptions};
use serde_json::json;

// Create options with builder pattern
let options = FuseOptions::default()
    .set_include_score(true)
    .set_keys(vec!["title", "author"]);

// Create Fuse instance
let fuse = Fuse::new(&data, &options);

// Search
let results = fuse.search("query");
```

### Configuration Options
- Use builder pattern for `FuseOptions`
- Provide sensible defaults
- Allow granular control over search behavior
- Support both simple and advanced use cases

### Search Results
- Return structured results with scores and match indices
- Support optional match highlighting through indices
- Provide consistent scoring (0.0 = perfect match, 1.0 = no match)

## Testing Guidelines

### Test Organization
- Unit tests in same file as implementation
- Integration tests in `tests/` directory
- Test file naming: `{module}_test.rs`

### Test Categories
1. **Algorithm Tests**: Test core search algorithms
2. **Option Tests**: Test configuration variations
3. **Edge Cases**: Empty strings, long patterns, special characters
4. **Performance Tests**: Benchmark critical paths

### Test Patterns
```rust
#[test]
fn test_feature_description() {
    // Arrange
    let options = FuseOptions::default();
    let search = BitmapSearch::new(pattern, options);
    
    // Act
    let result = search.search_in(text);
    
    // Assert
    assert!(result.is_match);
    assert!(result.score < 0.1);
}
```

## Implementation Guidelines

### When implementing new features:

1. **Search Algorithms**: Implement the `Searcher` trait
2. **Match Types**: Extend the `BaseMatch` trait for extended search
3. **Options**: Add to `FuseOptions` with builder methods
4. **Results**: Ensure consistent `SearchResult` structure

### Memory Management
- Prefer borrowing over cloning when possible
- Use `Cow<str>` for flexible string handling
- Consider `Arc` for shared immutable data
- Avoid unnecessary allocations in hot paths

### Regex Usage
- Use `OnceLock` for static regex compilation
- Compile regexes once, use many times
- Handle regex errors gracefully

### String Processing
- Support case-insensitive search
- Handle diacritics/accents when `ignore_diacritics` is enabled
- Use efficient string search algorithms

## WebAssembly Considerations

When working on `fuse-wasm`:
- Use `wasm-bindgen` for JavaScript interop
- Keep API surface minimal and JavaScript-friendly
- Handle serialization/deserialization carefully
- Consider memory usage in browser environment

## Node.js Considerations

When working on `fuse-node`:
- Use Neon for Rust-Node.js bindings
- Provide idiomatic JavaScript API
- Handle async operations appropriately
- Ensure proper resource cleanup

## Performance Optimization

### Critical Paths
1. Pattern alphabet creation (bitmap search)
2. Character matching loops
3. Score computation
4. Index conversion

### Optimization Strategies
- Pre-compute pattern alphabets
- Use bit operations for fast matching
- Minimize string allocations
- Cache frequently accessed data

## Future Considerations

- Maintain API compatibility across versions
- Consider parallel search for large datasets
- Support for custom scoring functions
- Enhanced query syntax support
- Streaming search capabilities

## Development Workflow

1. Write tests first for new features
2. Implement minimal viable functionality
3. Optimize after correctness is established
4. Update documentation and examples
5. Consider cross-platform compatibility

Remember: This is a performance-critical library where search speed and memory efficiency are paramount. Always profile and benchmark significant changes.
